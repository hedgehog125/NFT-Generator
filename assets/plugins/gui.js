{info:{id:"BagelGUI",description:"A customisable plugin for creating GUIs in Bagel.js."},plugin:{scripts:{init:(e,t)=>{t.add.asset.snd({id:".BagelGUI.click",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAAAwAABBIAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBg0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ////////////////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQCzSEAAeAAAAQSSYAuqwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEnACyvdAAACoh3exu8jLeoIAgcKAgCAYLggCAIHCgIAhggGIPv5cEFg+D+sH/Lg4CHDHKHP/E4PghrBwMcEAQygY//BB3//+UBAEAx/KAhlAQcmYqIp0mTVUZDWGgyrJEUQYImG/BhWy0KoEQVVjZUyyAxi+zMxAcDuX+WiWnPTQwFZ4BkIgoSlO0HWRLRa6sZiyXtxgTnQ+IAlwFSpHstGDFzlpJ1J2pzS2mZiuluTRlbS2DUE23jTFgFMVrERfV4GUv7edHTZbTQ3CYA37KYccp4lAmlpzMpkEOspbRYs7LIi8j8MQbxBMzxd8NvvB7KbTgw4yl1W5P67sEQS7sYhl3Zx/ZbS7xUzi6X+TZJFYkkYszmT+NETCdJdz7uFIpTWyjsNSdyauojEpdBNNLm408Oz/87DE4loUgqsfmMAkgxuzs47j+VGWS1u8Uf913bjdZa8ehyAaaIu7EXJhhwZC4VK+0ifZr0F/j++Y/vHW6WVZwzAUWZ7FrTIbUonIxGL0OUt+9G5e5cXmm3gp+aBnEQfaROjKqF/Zl/ZQ+smaVSuk8zSmJNFZVG2Gv9BMO/dpccfkF6/er5y/LC67MYfWchq4/0fVrKAIu7lfHLva4zAQE2q//1VFBQEBKMzKuGAhVCgJqs+qAnVAVL/6vxmKMx///9VTqr/V9VXjMUZvgYCAQNP9YKrBX8S8ShsSgrEVZ0RBwRPg1Bp5U7rBUeGpUNiU78RBwRPUIoilTusFR4KqTEFNRTMuOTkuM6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/zYMTZGtmybx/DGACqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg=="}),t.add.asset.snd({id:".BagelGUI.clickUp",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABMkATk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDLCEAAeAAAATJpqKjmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAFogGux9BAAC6qruoVWtAv0iG8oCDgQcUBA4Jz8pLg+D+IAQd5cHwfB/rP/BAEDkoGPxACYPg+D5+GPUCAIA+/8HwQBAEAQBMH/h/8EAQBB3UCAPg+H/wQDH8HwfD8uD4Pg+qushml2hmlAYBrCAMEjTYbZgXKSJMQKAAkRyGgr9CoNCahLjLRnVAAhorQiAL13knoq8qAdYdH1rCt6FqmTC2dsHT1HCMoc2jWLUjdBRNoyJv4RMO0+0ZrvFNRFbrNnkWi/kVZar+lnZySwWwG4+ixJ1YkCQ+8pbp5BEMtK0x06WUrt+hjNymv+3B3YjhSwzfl+pU8dytnvDLdWPVbMpuUdPNWprdLVi9irfi0sqU17Ofj8Oyrct1AT9y2td13+c+7WpqbfJqlpatarGeX5Xf7rD/86DE0Up0bqMfmsAAw5zWN6btVKDKzU7yzzKbyps6amyrU1/uWWOOP8paa13k1DVLjTV7tumz7llnhjZyws6t1pfMyHcons7H42c6avS27mprVaNVbUzS/vdL3u/5l3+5fv7N/qaMNZRoSaM02g0LO2aTFcDsQUEAsfvVoGoStQqLLLRgFURCVLcDdYiz5huShkdWIiu/qVSyzERIxDHQ0pUtZNFTUECvRA6UymyVysMPMABBJfQHFAUZwC8TIEEyk3udBhrpMhGCRxJYZOULpBco1Sk7HGyX0/l6VsgUOZnGH2U2MI0A8GLUeKwWfCoQ8E0F/6BprcYalVlOdmj4tNyf6VXuLTLIuC/LorRbMhlMYw1BN2yzJs8dd2zGcZmTN3lUWlUzOQ3H4CpuPEw6G8qsZxtNxgFx//OwxNNQVC56/5jICGCqtSrclTdpucj0tjkRoKGIwTcd2njO6CtVptyqNXJuK0t2kpst61lv+a139Y6nN092prC19Ncls5QzfIlc3CL8BS+tasZXvm3RityJRaIxGw+0pj0Na7jvWWst/v//////UpprXcqYjJN1BQCkqkxBTUUzLjk5LjOqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/8xDE8QAAA/wBwAAAqqqqqqqqqqqqqqqqqg=="}),t.add.asset.snd({id:".BagelGUI.touch",src:"data:audio/mpeg;base64,//OAxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAABP0ASkpKSkpKSkpKSkpKSkpKSkpKSkpKSkpKlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn/////////////////////////////////AAAAUExBTUUzLjk5cgRuAAAAAAAAAAA1CCQDKiEAAeAAAAT9uAw0pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zoMQAEjkqnedDMACyMBL0ufxEQvkRC3REREKgYACCEe7JpkEIy7Jp3Ed7Jp3vezyad7+9nkyd7BMmH8uf8Tg+8uD4f/l///Ln/5d//h///rB9//g+z7q7iFlKYTSjQDSknrKLQgSoGlObS2JMhgJeYvuY7AQqCdmwWOKDMmn7BoHzfVVVDBTsLMmppKqLp0vOKCTvSCZkpdHXbYjEnpVuWSqo6TdY6z5ur2PA3FrEqV1EYgu8tyumPPoyarCXtXFGr8QhiZqr8pX8uxX4koFKn9eB8HDaw7rWJFKXioqVfzRW6vxFrMeu5RKAaDjxU8JmvtRDCV2s7eEsvZyCV49gGxGsaOrQvzT1XFsZczpYai2PYeyq3GyRSXSh3n8sSyN237rWKSKdhqLdhtiVC9kzIIlEpq69DRb/86DE406karb/mMAFHbtWq4NWxKsdSq9Wpq3JuxT27ff5X7T3+U+X2/yntXm4vk5WpFjMzsGWX6qVJdG5dlTRyHoL7Wz/Gl7rKm3KvrV8cfpr8Zw5vm+/vt/G9V5re6lXCtV5KptKs5xLtdN7LRLNNperiCirq5ChNOZN0QkNyLgShrjSgaOXwEQpl1LzMZFtXeJAWG2ugwCMCNzUA833wAgJFXiAwSlUnkYugAJmMGF1gGAPCykUA0eGnu4YEOjRSYWOGAildqzYmsuUy5iUvmJQAQcyg7MCIzJAUw00r8huy/cNv9U28b9Oy0iBBCHGPhRiiWYIThCaZeuGOoyQ7WYu15yXHdWd9Z6msOrSf+Mpywm2TF6mlNJAaDCEAQJmBCbMc6sImYkzqn5TydmE5FtTFmXQHCpN//PAxNRcDG6O/5nYDVKDH5bfR9WU0pr5ggqBA8oDTAQqCi/xcpSpqVz8LlBLOfbs5VZXujdmZpdX5qLSKjpb0upn9qw66lmtflMqp05X1a6/rouqyKIwwBQqKvq+Evp6ksmbcY7m78VoYzhVr5T7cG3l0W5dptdpH/ll+zVtWfx5LUJyri9r6yHdWgjThQG12U2M5TSRrGgXNn3///3/P////99pfGdgs1VMQU1FVUxBTUUzLjk5LjNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//MQxPIAAAP8AcAAAFVVVVVVVVVVVVVVVVU="})}},types:{sprites:{GUI:{description:"Creates and manages a GUI.",args:{submenu:{required:!0,check:(e,t)=>{if(null==t.submenus[e])return"Oh no! That submenu doesn't seem to exist. Make sure it's added in the \"submenus\" argument."},types:["string"],description:"The id of the submenu to start in."},submenus:{required:!0,subcheck:{elements:{required:!0,types:["array"],check:e=>{e.internal={dontClone:!0}},checkEach:!0,subcheck:{type:{required:!0,types:["string"],description:"The type of element."},visible:{required:!1,default:!0,types:["boolean"],description:"If the element is visible or not."},fixedToCamera:{required:!1,default:!1,types:["boolean"],description:"If the element should be fixed to the camera or not. This will mean it won't move when the camera moves. It will reattatch temporarily for an animation though."},x:{required:!1,types:["number","string","function"],description:"The x position of the element."},y:{required:!1,types:["number","string","function"],description:"The y position of the element."},left:{required:!1,types:["number","function"],description:"The x position of the left side of the element."},top:{required:!1,types:["number","function"],description:"The y position of the top of the element."},right:{required:!1,types:["number","function"],description:"The x position of the right side of the element."},bottom:{required:!1,types:["number","function"],description:"The y position of the bottom of the element."},internal:{required:!1,types:["object"],description:"Stores some internal values."}},ignoreUseless:!0,arrayLike:!0,description:"The elements for this submenu."},scroll:{required:!1,default:{},types:["object"],subcheck:{x:{required:!1,subcheck:{min:{required:!0,types:["number"],description:"The minimum camera x when scrolling. The left-most side of the submenu."},max:{required:!0,types:["number"],description:"The maximum camera x when scrolling. The right-most side of the submenu."}},types:["object"],description:"Options for scrolling horizontally."},y:{required:!1,subcheck:{min:{required:!0,types:["number"],description:"The minimum camera y when scrolling. The top of the submenu."},max:{required:!0,types:["number"],description:"The maximum camera y when scrolling. The bottom of the submenu."}},types:["object"],description:"Options for scrolling horizontally."}},description:"Scrolling options for this submenu."},camera:{required:!1,default:{},subcheck:{x:{required:!1,default:0,types:["number"],description:"The x position."},y:{required:!1,default:0,types:["number"],description:"The y position."}},types:["object"],description:"The initial camera position for this submenu."},init:{required:!1,types:["function"],description:"A function that runs when this submenu is switched to, after the animation has completed. It's called with the menuSprite and game objects."},main:{required:!1,types:["function"],description:"A function that runs when this submenu is active, after the animation has completed. Called with the menuSprite and game objects."},animationInit:{required:!1,types:["function"],description:"A function that runs as soon as this submenu is switched to, when the animation first starts. Called with the menuSprite, animationVars, submenuChangeAnimation and game."},animationMain:{required:!1,types:["function"],description:"A function that runs as soon as this submenu is active, when the animation is active. It's called with the menuSprite, animationVars, submenuChangeAnimation and game."},hoverText:{required:!1,types:["object"],default:{},subcheck:(e=>{let t=Bagel.internal.deepClone(Bagel.internal.plugin.plugin.types.sprites.text.args);t.fixedToCamera={required:!1,default:!0,types:["boolean"],description:"If the hover text should be fixed to the camera or not. You'll almost always want this to be true (the default)."},t.fadeTime={required:!1,default:.15,types:["number"],description:"How long the text should fade in and out for. In seconds."},delete t.text;let i={x:game.width/2,bottom:game.height-10};for(let e in i)t[e].default=i[e];return t})()}},types:["object"],arrayLike:!0,description:"The submenus in this menu. The key is the id and the value is an object."},stateToActivate:{required:!0,types:["string"],description:"The game state that this submenu is active."}},cloneArgs:null,check:(e,t,i,n)=>{for(let t in e.submenus){let i=e.submenus[t].elements;for(let e in i){let t=i[e].type;if(null==n.vars.types.elements[t])return"Huh, the type "+JSON.stringify(t)+" doesn't seem to exist. It has to be one of these:\n"+Object.keys(n.vars.types.elements).map(e=>" â€¢ "+JSON.stringify(e)+" -> "+n.vars.types.elements[e].description).join("\n")+"\nCheck you haven't mispelt it and that you added the GUIElement asset."}}let r=e.internal;r.initialSubmenu=e.submenu,r.plugin=n,((e,t)=>{e.internal.finishAnimation=(i=>{t.vars.finishAnimation(e,t)})})(e,n),e.scripts.main.push({code:(e,t)=>{let i=e.internal,n=i.plugin,r=!1;i.queuedSubmenuChangeAnimation&&(e.submenu=i.queuedSubmenuChangeAnimation[0],i.submenuChangeAnimation=i.queuedSubmenuChangeAnimation[1],e.animationActive=!0,i.queuedSubmenuChangeAnimation=null,r=!0),e.submenu!=e.internal.lastSubmenu&&(n.vars.initMenu(e,n),i.lastSubmenu=e.submenu);let a=i.submenuChangeAnimation;if(a){let n=e.internal.plugin.vars.types.animations[a.type].menuSprite.main;n&&n(e,a,i.animationVars,i.finishAnimation,t,e.vars.plugin);let s=e.submenus[e.submenu];r&&s.animationInit&&s.animationInit(e,i.animationVars,i.submenuChangeAnimation,t)}},stateToRun:e.stateToActivate});for(let r in e.submenus){let a=e.submenus[r].elements;for(let s in a){let l=a[s],o=Bagel.internal.getTypeOf(l);if("object"!=o)return"Huh, sprite.elements item "+s+" is "+Bagel.internal.an(o)+"type. It should be an object.";let m=n.vars.types.elements[l.type],q="Game.game.sprites item "+e.idIndex+".elements item "+s;if(i({ob:l,where:q,syntax:{...m.args,...n.vars.checks.ignoreElement}}),l.submenu=r,m.check){let r=m.check(l,i,q,e,n,t);if(r)return r}}}},init:(e,t,i)=>{let n=e.internal;n.spriteElements=[],n.previousSpriteElements=[],n.spriteElementQueue=[],n.elementTypeVars={},e.camera={x:0,y:0},e.animationActive=!1,n.getFutureID=((e,t,i)=>n=>t(i,e,n))(t,i.vars.findID,e.id),i.vars.elementTypeInit(e,i,!1),i.vars.menuSpriteCount++},tick:(e,t,i)=>{let n=e.internal,r=e.submenus[e.submenu];if(Bagel.internal.current.pluginProxy=!0,n.submenuChangeAnimation)r.animationMain&&r.animationMain(e,n.animationVars,n.submenuChangeAnimation,t);else{r.main&&r.main(e,t);let i=r.scroll;i.x&&(1==Math.sign(t.input.scrollDelta.x)?e.camera.x<i.x.max&&(e.camera.x=Math.min(e.camera.x+t.input.scrollDelta.x,i.x.max)):e.camera.x>i.x.min&&(e.camera.x=Math.max(e.camera.x+t.input.scrollDelta.x,i.x.min))),i.y&&(1==Math.sign(t.input.scrollDelta.y)?e.camera.y<i.y.max&&(e.camera.y=Math.min(e.camera.y+t.input.scrollDelta.y,i.y.max)):e.camera.y>i.y.min&&(e.camera.y=Math.max(e.camera.y+t.input.scrollDelta.y,i.y.min)))}for(let t in n.spriteElementQueue){let r=n.spriteElementQueue[t],a=r.code;delete r.code,a(i.vars.makeSpriteElement(r.data,e,i,r.element,r.originalElement,r.a,r.linkedElements,r.where),e,i,r.callbackData)}n.spriteElementQueue=[]},listeners:{events:{delete:(e,t,i)=>{let n=e.internal;for(let e in n.spriteElements){let t=n.spriteElements[e];t&&t.delete()}let r=i.vars.types.elements;for(let e in r){let a=r[e];a.onMenuSpriteDelete&&a.onMenuSpriteDelete(n.elementTypeVars[e],t,1==i.vars.menuSpriteCount)}i.vars.menuSpriteCount--}}}}}},methods:{sprite:{animateSubmenuChange:{fn:{fn:(e,t,i,n)=>{if(t.submenu==e.submenu)return;for(let e in t.optionalValues)null==t.animation[e]&&(t.animation[e]=t.optionalValues[e]);for(let e in t.defaultOverwrites){let i=t.defaultOverwrites[e];t.animation[i]=t.optionalValues[i]}let r=e.internal;r.queuedSubmenuChangeAnimation=[t.submenu,t.animation],r.animationVars={internal:{dontClone:!0}},e.internal.previousSpriteElements=[...e.internal.spriteElements]},args:{submenu:{required:!0,types:["string"],description:"The submenu to switch to."},animation:{required:!0,types:["object"],description:'The animation object. The arguments depend on the animation but the "type" argument is always required.'},optionalValues:{required:!1,default:{},types:["object"],description:"Allows required arguments to be made optional by using the value set here when unspecficied. For example, a button has a colour so a default can be set like this: menuSprite.animateSubmenuChange(..., ..., {color: element.color});"},defaultOverwrites:{required:!1,default:[],types:["array"],description:"The arguments that should be overwritten because they've defaulted to a value that isn't specific to this instance."}},obArg:!1,appliesTo:["GUI"]}}}},listeners:{prepState:(e,t,i)=>{for(let n in t.game.sprites){let r=t.game.sprites[n];if(r&&"GUI"==r.type){let t=r.internal;if(r.stateToActivate==e)t.initialized||(t.initialSubmenu=r.submenu,t.lastSubmenu=r.submenu,i.vars.initMenu(r,i,!t.previouslyInitialized),t.previouslyInitialized=!0);else{for(n in r.submenu=t.initialSubmenu,t.initialized=!1,t.spriteElements){let e=t.spriteElements[n];e&&e.delete()}t.spriteElements=[]}}}}}},vars:{menuSpriteCount:0,initMenu:(e,t,n)=>{let r=e.internal;r.spriteElementQueue=[],t.vars.elementTypeInit(e,t,!0);let a=e.submenus[e.submenu],s=e.game;if(r.initialElements=Bagel.internal.deepClone(a.elements),n){for(let i in e.submenus){let n=e.submenus[i].elements;for(let e in n){let i=n[e],r=t.vars.types.elements[i.type];r.preload&&r.preload(i,s,t)}}if(0!=s.internal.assets.loading)return}let l=r.submenuChangeAnimation,o=l?t.vars.types.animations[l.type]:{},m=e.submenus[r.lastSubmenu];m.camera.x=e.camera.x,m.camera.y=e.camera.y,e.camera.x=a.camera.x,e.camera.y=a.camera.y;let q,d=r.spriteElements;if(l){let i=o;i.menuSprite.init&&(Bagel.internal.saveCurrent(),Bagel.internal.current.sprite=e,(q=i.menuSprite.init(e,l,r.animationVars,s,t,r.finishAnimation))&&(Array.isArray(q)||(q=[q])),Bagel.internal.loadCurrent())}for(let t in d){let i=d[t];if(i){let t=i.vars;t.old=!0,0==t.spriteElementID&&(t.element.fixedToCamera?(t.element.x+=e.camera.x,t.element.y+=e.camera.y,t.element.fixedToCamera=!1):(t.element.x-=m.camera.x-e.camera.x,t.element.y-=m.camera.y-e.camera.y)),t.animationInitialized=!1,t.elementAnimationVars={}}}for(i in r.initialElements){let n=Bagel.internal.deepClone(r.initialElements[i]),a=Bagel.internal.deepClone(n),l=t.vars.types.elements[n.type],o="function"==typeof l.spriteDatas?l.spriteDatas(n,s,e.internal.getFutureID,e,t,r.elementTypeVars[n.type]):l.spriteDatas;null==o?o=[]:Array.isArray(o)||(o=[o]);e.internal.spriteElements;let m=[];for(let i in o){let r=o[i];t.vars.makeSpriteElement(r,e,t,n,a,i,m,"the plugin BagelGUI element type "+n.type+".spriteDatas item "+i)}}for(let i in q){let n=q[i];n.id=t.vars.findID(e.id,s),n.vars||(n.vars={}),n.vars.menuSprite=e,n.vars.plugin=t,n.vars.animation=l,n.vars.animationVars=r.animationVars,n.vars.isAnimationSprite=!0,n.scripts||(n.scripts={}),n.scripts.init||(n.scripts.init=[]),n.scripts.init.splice(0,0,{code:t.vars.process.element.overrideDelete,stateToRun:s.state});let a=s.add.sprite(n,"the "+Bagel.internal.th(parseInt(i))+" sprite created by the "+JSON.stringify(l.type)+" animation in menuSprite.init");t.vars.addSpriteElement(a,e)}r.initialized=!0},findID:(e,t,i=0)=>{let n=0;for(;;){let r=e+"#"+n;if(!t.get.sprite(r,!0)){if(0==i)return r;i--}n++}},queueMakeSpriteElement:(e,t,i,n,r,a,s,l=0,o=[],m="the function BagelUI.vars.makeSpriteElement")=>{i.internal.spriteElementQueue.push({data:t,element:r,originalElement:a,a:l,linkedElements:o,where:m,code:e,callbackData:s})},makeSpriteElement:(e,t,i,n,r,a=0,s=[],l="the function BagelUI.vars.makeSpriteElement")=>{let o=t.game,m=t.internal,q=m.submenuChangeAnimation,d=q?i.vars.types.animations[q.type]:{};e.id=i.vars.findID(t.id,o),e.vars={...e.vars,element:n,originalElement:r||Bagel.internal.deepClone(n),spriteElementID:a,animation:q,animationVars:m.animationVars,menuSprite:t,plugin:i,elementAnimationVars:{},elementTypeVars:m.elementTypeVars[n.type],linkedElements:s},e.vars.old=!1,e.visible=!1,d.hideNew&&(e.vars.element.visible=!1),e.scripts||(e.scripts={}),e.scripts.init||(e.scripts.init=[]),e.scripts.main||(e.scripts.main=[]),e.minProcess?(e.scripts.init.splice(0,0,{code:i.vars.process.element.minInit,stateToRun:o.state,affectVisible:!1}),e.scripts.main.splice(0,0,{code:i.vars.process.element.minMain,stateToRun:o.state})):(e.scripts.init.splice(0,0,{code:i.vars.process.element.init,stateToRun:o.state,affectVisible:!1}),e.scripts.main.splice(0,0,{code:i.vars.process.element.main,stateToRun:o.state}));let u=e.minProcess?0:1;for(;u<e.scripts.init.length;){let t=e.scripts.init[u];"object"==typeof t?(null==t.stateToRun&&(t.stateToRun=o.state),t.affectVisible=!1):"function"==typeof t&&(e.scripts.init[u]={code:t,stateToRun:o.state,affectVisible:!1}),u++}for(u=e.minProcess?0:1;u<e.scripts.main.length;){let t=e.scripts.main[u];"object"==typeof t?null==t.stateToRun&&(t.stateToRun=o.state):"function"==typeof t&&(e.scripts.main[u]={code:t,stateToRun:o.state}),u++}let h=["minProcess","deleteOnOtherDelete"];for(u in e.vars.tags={},h)e.hasOwnProperty(h[u])&&(e.vars.tags[h[u]]=e[h[u]],delete e[h[u]]);let c=o.add.sprite(e,l);return i.vars.addSpriteElement(c,t),s.push(c),c},addSpriteElement:(e,t)=>{let i=t.internal.spriteElements,n=0;for(;n<i.length&&null!=i[n];)n++;return i[n]=e,n},finishAnimation:(e,t)=>{let i=e.internal,n=i.spriteElements,r=i.submenuChangeAnimation?t.vars.types.animations[i.submenuChangeAnimation.type]:{};i.submenuChangeAnimation=null,e.animationActive=!1;let a=i.previousSpriteElements;for(let e in a)a[e]&&(delete n[n.findIndex(t=>t&&t.id==a[e].id)],a[e].delete());for(let e in n)if(n[e])if(n[e].vars.isAnimationSprite)n[e].delete(),delete n[e];else{let t=n[e].vars.element,i=n[e].vars.originalElement;t.x=i.x,t.y=i.y,i.fixedToCamera&&(t.fixedToCamera=!0),r.hideNew&&(t.visible=i.visible)}i.previousSpriteElements=[],e.camera.x=0,e.camera.y=0,e.submenus[e.submenu].init&&(Bagel.internal.current.pluginProxy=!0,e.submenus[e.submenu].init(e,e.game))},elementTypeInit:(e,t,i)=>{let n=e.internal,r=t.vars.types.elements;for(let e in r){let t=r[e];n.elementTypeVars[e]={internal:{dontClone:!0}},t.initType&&t.initType(n.elementTypeVars[e],game,i)}},process:{element:{overrideDelete:e=>{e.internal.delete=e.delete,(e=>{e.delete=(t=>{let i=e.vars.plugin.vars.types.elements[e.vars.element.type];i.onDelete&&i.onDelete(e,e.vars.element,e.vars.elementTypeVars,e.game);let n=e.vars.menuSprite,r=n.internal.spriteElements.findIndex(t=>t&&t.id==e.id);if(-1!=r&&delete n.internal.spriteElements[r],-1!=(r=n.internal.previousSpriteElements.findIndex(t=>t&&t.id==e.id))&&delete n.internal.previousSpriteElements[r],e.vars.linkedElements&&!e.vars.dontDeleteOthers)for(let t in e.vars.linkedElements)0!=t&&null!=e.vars.linkedElements[t]&&e.vars.linkedElements[t].vars.tags.deleteOnOtherDelete&&(e.vars.linkedElements[t].vars.dontDeleteOthers=!0,e.vars.linkedElements[t].delete());e.internal.delete()})})(e)},hideIfOffScreen:e=>{let t=e.vars.element.visible;e.x>game.width/2?e.left>game.width&&(t=!1):e.right<0&&(t=!1),e.y>game.height/2?e.top>game.height&&(t=!1):e.bottom<0&&(t=!1),e.visible=t},initElementPosition:e=>{if(0==e.vars.spriteElementID){null==e.width&&(e.width=e.game.width),null==e.height&&(e.height=e.game.height);let t=e.vars.element;t.hasOwnProperty("x")&&"centered"!=t.x?e.x=t.x:t.hasOwnProperty("right")?e.right=t.right:t.hasOwnProperty("left")?e.left=t.left:t.hasOwnProperty("x")&&(e.x=t.x),t.hasOwnProperty("y")&&"centered"!=t.y?e.y=t.y:t.hasOwnProperty("bottom")?e.bottom=t.bottom:t.hasOwnProperty("top")?e.top=t.top:t.hasOwnProperty("y")&&(e.y=t.y),t.x=e.x,t.y=e.y,e.vars.originalElement.x=e.x,e.vars.originalElement.y=e.y}},minInit:e=>{e.vars.plugin.vars.process.element.overrideDelete(e);e.vars.menuSprite;let t=e.vars.element;e.vars.plugin.vars.process.element.initElementPosition(e),t.fixedToCamera?(e.x=t.x,e.y=t.y):(e.x=t.x-e.vars.menuSprite.camera.x,e.y=t.y-e.vars.menuSprite.camera.y),e.vars.plugin.vars.process.element.hideIfOffScreen(e)},init:e=>{if(e.vars.plugin.vars.process.element.minInit(e),e.vars.animation){let t=e.vars.element;t.fixedToCamera&&(t.x+=e.vars.menuSprite.camera.x,t.y+=e.vars.menuSprite.camera.y,t.fixedToCamera=!1);let i=e.vars.plugin.vars.types.animations[e.vars.animation.type].elements.create;i&&i(t,e.vars.animation,e.vars.menuSprite,e.game,e.vars.plugin,e)}},minMain:e=>{let t=e.vars.menuSprite.internal.submenuChangeAnimation;e.vars.active=!t&&e.visible,e.vars.plugin.vars.process.element.hideIfOffScreen(e),e.vars.active&&e.layer.bringToFront()},main:e=>{let t=e.vars.element,i=e.vars.menuSprite.internal.submenuChangeAnimation;if(e.vars.active=!i&&e.visible,i){let n=e.vars.plugin.vars.types.animations[i.type].elements,r=e.vars.menuSprite.internal.submenuChangeAnimation;e.vars.animationInitialized||(n.init&&n.init(t,r,e.vars.menuSprite.internal.animationVars,e.vars.menuSprite,e.game,e.vars.plugin,e),e.vars.animationInitialized=!0),n.main&&n.main(t,r,e.vars.menuSprite.internal.animationVars,e.vars.menuSprite.internal.finishAnimation,e.vars.menuSprite,e.game,e.vars.plugin,e)}t.fixedToCamera?(e.x=t.x,e.y=t.y):(e.x=t.x-e.vars.menuSprite.camera.x,e.y=t.y-e.vars.menuSprite.camera.y),e.vars.plugin.vars.process.element.hideIfOffScreen(e),e.vars.active&&e.layer.bringToFront()}}},types:{animations:{scroll:{elements:{create:(e,t,i,n,r,a)=>{let s;a.vars.animationVars.notEmpty=!0;let l=0,o=0;"left"==t.direction?(s=e.x,l=-n.width):"right"==t.direction?(s=e.x,l=n.width):"up"==t.direction?(s=e.y,o=-n.height):(s=e.y,o=n.height),t.stillCamera?t.scrollOld||(a.vars.elementAnimationVars.initialPosition=s,e.visible=!1,e.x-=l,e.y-=o):(e.x+=l,e.y+=o)},init:(e,t,i,n,r,a,s)=>{if(t.stillCamera&&s.vars.old==t.scrollOld){if(t.scrollOld){let i;i="left"==t.direction||"right"==t.direction?e.x:e.y,s.vars.elementAnimationVars.initialPosition=i}t.scrollOld?s.layer.bringToFront():e.visible=s.vars.originalElement.visible}},main:(e,t,i,n,r,a,s,l)=>{if(t.stillCamera&&l.vars.old==t.scrollOld){let n,r=l.vars.elementAnimationVars.initialPosition;"left"==t.direction||"right"==t.direction?(e.x+=i.vel,n=e.x-r):(e.y+=i.vel,n=e.y-r),t.scrollOld?"left"==t.direction?n<=-a.width&&(e.x=r-a.width,i.finished=!0):"right"==t.direction?n>=a.width&&(e.x=r+a.width,i.finished=!0):"up"==t.direction?n<=-a.height&&(e.y=r-a.height,i.finished=!0):"down"==t.direction&&n>=a.height&&(e.y=r+a.height,i.finished=!0):"left"==t.direction?n<=0&&(e.x=r,i.finished=!0):"right"==t.direction?n>=0&&(e.x=r,i.finished=!0):"up"==t.direction?n<=0&&(e.y=r,i.finished=!0):"down"==t.direction&&n>=0&&(e.y=r,i.finished=!0)}}},menuSprite:{init:(e,t,i)=>{t.stillCamera||("left"==t.direction||"right"==t.direction?i.initialCameraPosition=e.camera.x:i.initialCameraPosition=e.camera.y),"left"==t.direction||"up"==t.direction?i.vel=-5:i.vel=5},main:(e,t,i,n)=>{let r=e.game;if("left"==t.direction?i.vel-=r.width/125:"right"==t.direction?i.vel+=r.width/125:"up"==t.direction?i.vel-=r.height/125:i.vel+=r.height/125,t.stillCamera)!i.finished&&i.notEmpty||n();else{let a;"left"==t.direction||"right"==t.direction?(e.camera.x+=i.vel,a=e.camera.x-i.initialCameraPosition):(e.camera.y+=i.vel,a=e.camera.y-i.initialCameraPosition),"left"==t.direction?a<=-r.width&&(e.camera.x=i.initialCameraPosition-r.width,n()):"right"==t.direction?a>=r.width&&(e.camera.x=i.initialCameraPosition+r.width,n()):"up"==t.direction?a<=-r.height&&(e.camera.y=i.initialCameraPosition-r.height,n()):"down"==t.direction&&a>=r.height&&(e.camera.y=i.initialCameraPosition+r.height,n())}i.vel*=.9}},args:{direction:{required:!1,default:"right",types:["string"],check:e=>{if(!["left","right","up","down"].includes(e))return'Oh no! This must be either "left", "right", "up" or "down".'},description:'The direction for either the camera to scroll (so the elements scroll the opposite way). Or either the old or new elements (depends on "scrollOld") to scroll (if "stillCamera" is true). Either "left", "right", "up" or "down".'},stillCamera:{required:!1,default:!1,types:["boolean"],description:"If the camera shouldn't move and either the new or old elements should move instead or not. If set to true and \"scrollOld\" set to false, you'll want a new background to cover up the old elements."},scrollOld:{required:!1,default:!1,types:["boolean"],description:'Only applies when "stillCamera" is true. Determines if the old or new elements should move.'}},description:"Either the camera, new elements or old elements scroll in one of four directions to reveal the elements in another submenu."},triangleScroll:{elements:{main:(e,t,i,n,r,a,s,l)=>{i.covered&&!i.coveredDone&&(l.vars.old?l.delete():(e.visible=l.vars.originalElement.visible,l.layer.bringToFront()))}},menuSprite:{init:(e,t,i,n,r,a)=>{let s=t.direction;return"left"==s||"right"==s?(i.triangleWidth=n.height/2,i.triangleHeight=n.height):(i.triangleWidth=n.width/2,i.triangleHeight=n.width),{type:"canvas",fullRes:!0,width:i.triangleWidth,height:i.triangleHeight,mode:"static",vars:{dir:s,vel:0,finish:a},clones:{prerender:(e,t,i,n)=>{if(i.fillStyle="black",0==e.cloneID){let n=e.vars.dir;"left"==n||"right"==n?(e.width=1.25*t.width,e.height=t.height):(e.width=t.width,e.height=1.25*t.height),i.fillRect(0,0,1,1)}else i.clearRect(0,0,n.width,n.height),i.beginPath(),i.moveTo(0,0),i.lineTo(n.width,0),i.lineTo(n.width,n.height/2),i.lineTo(0,0),i.fill(),i.beginPath(),i.moveTo(0,n.height),i.lineTo(n.width,n.height),i.lineTo(n.width,n.height/2),i.lineTo(0,n.height),i.fill(),e.vars.otherClone=t.get.sprite(e.parent.cloneIDs[0])},scripts:{main:[(e,t)=>{e.layer.bringToFront();let i=e.vars.dir;"left"==i?(0==e.cloneID?e.left=e.parent.right:e.left=e.vars.otherClone.right,e.right<0&&1==e.cloneID&&(e.parent.vars.done=!0)):"right"==i?(0==e.cloneID?e.right=e.parent.left:e.right=e.vars.otherClone.left,e.left>t.width&&1==e.cloneID&&(e.parent.vars.done=!0)):"up"==i?(0==e.cloneID?e.top=e.parent.y+e.parent.width/2:e.y=e.vars.otherClone.bottom+e.width/2,e.bottom<0&&1==e.cloneID&&(e.parent.vars.done=!0)):(0==e.cloneID?e.bottom=e.parent.y-e.parent.width/2:e.y=e.vars.otherClone.top-e.width/2,e.top>t.height&&1==e.cloneID&&(e.parent.vars.done=!0))}]}},scripts:{init:[{code:(e,t)=>{let i=e.vars.dir;"left"==i?(e.angle=-90,e.left=t.width):"right"==i?e.right=0:"up"==i?(e.angle=0,e.y=t.height+e.width/2):(e.y=-e.width/2,e.angle=180),e.clone({width:1,height:1,angle:90,fullRes:!1,updateRes:!1}),e.clone()},stateToRun:n.state}],main:[{code:e=>{let t=e.vars,i=t.dir;"left"==i||"up"==i?t.vel-=5:t.vel+=5,"left"==i||"right"==i?(e.x+=t.vel,"left"==i?e.right<0&&(e.vars.animationVars.covered=!0):e.left>n.width&&(e.vars.animationVars.covered=!0)):(e.y+=t.vel,"up"==i?e.bottom<0&&(e.vars.animationVars.covered=!0):e.top>n.height&&(e.vars.animationVars.covered=!0)),t.vel*=.9,e.vars.done&&e.vars.finish()},stateToRun:n.state}]},prerender:(e,t,i,n)=>{i.clearRect(0,0,n.width,n.height),i.fillStyle="black",i.beginPath(),i.moveTo(0,0),i.lineTo(0,n.height),i.lineTo(n.width,n.height/2),i.lineTo(0,0),i.fill()}}},main:(e,t,i)=>{i.covered&&(i.waited?i.coveredDone=!0:i.waited=!0)}},args:{direction:{required:!1,default:"right",types:["string"],check:e=>{if(!["left","right","up","down"].includes(e))return'Oh no! This must be either "left", "right", "up" or "down".'},description:'The direction for the triangle to move. Either "left", "right", "up" or "down".'}},hideNew:!0,description:"A fairly simple animation where a triangle covers up the screen before another triangle erases it and reveals the new submenu."},circle:{elements:{create:(e,t,i,n,r,a)=>{"open"==t.direction&&(a.vars.animationVars.notEmpty=!0,a.vars.elementAnimationVars.initialPosition=e.y,e.y+=n.height)},init:(e,t,i,n,r,a,s)=>{"close"==t.direction&&s.vars.old&&(s.vars.elementAnimationVars.initialPosition=e.y,s.bottom<0&&(s.vars.originalElement.visible=!1))},main:(e,t,i,n,r,a,s,l)=>{if("open"==t.direction&&!l.vars.old&&i.circleDone||"close"==t.direction&&l.vars.old&&!i.oldScrolled){e.visible=l.vars.originalElement.visible;let n=l.vars.elementAnimationVars.initialPosition;e.y+=i.vel;let r=e.y-n;"open"==t.direction?r<=0&&(e.y=n,i.finished=!0):r>=a.height&&(i.oldNearlyScrolled=!0,e.visible=!1)}"close"==t.direction&&i.oldScrolled&&!l.vars.old&&(e.visible=l.vars.originalElement.visible)}},menuSprite:{init:(e,t,i)=>{let n=e.game;if("open"==t.direction){let i=e.submenus[e.internal.lastSubmenu];t.x-=i.camera.x,t.y-=i.camera.y}else t.x-=e.camera.x,t.y-=e.camera.y;t.x=Math.max(Math.min(t.x,n.width),0),t.y=Math.max(Math.min(t.y,n.height),0),i.vel=3*("open"==t.direction?-1:1);let r="open"==t.direction?Math.max(n.width,n.height)*t.resolution:1;return{type:"canvas",mode:"static",x:"open"==t.direction?t.x:n.width/2,y:"open"==t.direction?t.y:-n.height/2,vars:{vel:2,burstTick:0,doneTick:0,renderMode:"open"==t.direction},fullRes:"open"==t.direction,prerender:(e,t,i,n)=>{if(e.vars.renderMode){i.fillStyle=e.vars.animation.color,i.beginPath();let t=n.width/2;i.arc(t,t,t,0,2*Math.PI),i.fill(),e.updateRes=!1,"open"==e.vars.animation.direction?e.width=e.vars.animation.initialSize:e.width=e.vars.pendingWidth,e.height=e.width}else if(i.fillStyle=e.vars.animation.color,i.fillRect(0,0,1,1),e.updateRes=!1,e.width=t.width,e.height=t.height,"open"==e.vars.animation.direction){e.x=t.width/2,e.y=t.height/2;let i=e.vars.menuSprite.camera;e.width+=i.x,e.height+=i.y,e.x-=i.x/2,e.y-=i.y/2}},scripts:{main:[{code:(e,t)=>{if(e.layer.bringToFront(),0==e.vars.doneTick)if(e.vars.animationVars.oldScrolled||"open"==e.vars.animation.direction){if("close"==e.vars.animation.direction&&!e.vars.oldScrolledWas){e.x=e.vars.animation.x,e.y=e.vars.animation.y;let i=Math.max(2*Math.max(e.x,t.width-e.x),2*Math.max(e.y,t.height-e.y));e.vars.pendingWidth=Math.floor(Math.sqrt(Math.pow(2*(i+1),2)/2)),e.width=Math.max(t.width,t.height)*e.vars.animation.resolution,e.height=e.width,e.vars.renderMode=!0,e.updateRes=!0,e.fullRes=!0,e.vars.oldScrolledWas=!0}if(e.vars.burstTick++,15==e.vars.burstTick?e.vars.vel+=50:e.vars.vel++,e.width+=e.vars.vel*("open"==e.vars.animation.direction?1:-1),e.height=e.width,"open"==e.vars.animation.direction){let i=Math.floor(Math.sqrt(2*Math.pow(e.width,2))/2);e.x-i/2<=0&&e.x+i/2>=t.width&&e.y-i/2<=0&&e.y+i/2>=t.height&&(e.vars.doneTick=1,e.vars.renderMode=!1,e.width=1,e.height=1,e.updateRes=!0,e.fullRes=!1)}else e.width<=1&&(e.delete(),e.vars.animationVars.finished=!0)}else e.y+=e.vars.animationVars.vel,"close"==e.vars.animation.direction&&e.y>t.height/2&&(e.y=t.height/2);else 16==e.vars.doneTick?e.y+=e.vars.animationVars.vel:15==e.vars.doneTick?(e.vars.doneTick++,e.vars.animationVars.circleDone=!0):e.vars.doneTick++},stateToRun:n.state}]},width:r,height:r}},main:(e,t,i,n)=>{"open"==t.direction?i.finished||i.circleDone&&!i.notEmpty?n():i.circleDone&&(i.vel-=game.height/200):(i.oldNearlyScrolled&&(i.oldScrolled=!0),i.oldScrolled?i.finished&&n():i.vel+=game.height/200)}},args:{x:{required:!0,types:["number"],description:"The x position of the circle."},y:{required:!0,types:["number"],description:"The y position of the circle."},color:{required:!0,types:["string"],description:'The colour of the circle, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'},direction:{required:!1,default:"open",check:e=>{if(!["open","close"].includes(e))return'Oh no! The direction has to be either "open" or "close".'},types:["string"],description:'The direction for the animation. Either "open" or "close".'},initialSize:{required:!1,default:1,types:["number"],description:"For the open direction. The diameter of the circle when the animation starts."},resolution:{required:!1,default:.5/window.devicePixelRatio,check:e=>{if(e<=0)return"Oh no! This has to be more than 0."},types:["number"],description:"The resolution scale of the animation. 1 is the full resolution of the canvas, 2 is 2x supersampling, 0.5 is half resolution etc."}},hideNew:!0,description:"A circle grows to fill the screen and the new elements slide on from the bottom."}},elements:{button:{args:{color:{required:!0,types:["string"],description:'The colour of the button, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'},size:{required:!0,types:["number"],description:"The height/diameter of the button. The width can be more than the height if the icon is wide."},width:{required:!1,types:["number"],description:"The width of the button. If unspecficied it'll default to the size of the button."},icon:{required:!1,types:["string"],description:"The ID of the image asset to use as an icon."},iconSize:{required:!1,default:.85,types:["number"],description:"The largest dimension of the image will be the button's current diameter multiplied by this number. The other dimension is calculated to keep the aspect ratio."},onClick:{required:!1,types:["object","function"],subcheck:{submenu:{required:!0,types:["string"],description:"The submenu to switch to when it's clicked."},animation:{required:!1,default:{},types:["object"],description:"The animation to use for the transition."}},description:"The action to happen when it's clicked. Set to an object with the \"submenu\" property set to the new submenu ID to change submenus. Set to a function to run code when it's clicked. It's called with the element, the sprite and the menuSprite."},onHover:{required:!1,types:["string","function"],description:"The action to happen when the button is hovered over. Either a message by setting it to a string or a function to run. It's called with the element, the sprite and the menuSprite."},shape:{required:!1,default:"circle",types:["string"],check:e=>{if(!["circle","square","hardSquare"].includes(e))return"Hmm, "+JSON.stringify(e)+' isn\'t an option. It has to be either "circle", "square" or "hardSquare".'},description:'The shape of the button. Either "circle", "square" or "hardSquare". Button widths and heights might not match when using long icons but these still use the same shape names.'}},initType:(e,t)=>{e.hoverTextSprite=null,e.hoverText=""},onMenuSpriteDelete:(e,t,i)=>{if(i){let e=".BagelGUI.button.circle";Bagel.internal.render.texture.get(e,t)&&Bagel.internal.render.texture.delete(e,t)}},preload:(e,t)=>{e.icon&&t.get.asset.img(e.icon)},check:(e,t,i,n,r,a)=>{if("object"==typeof e.onClick){let n=e.onClick.animation;null==n.type&&(n.type="scroll");let a=r.vars.types.animations[n.type];if(null==a){let e=Object.keys(r.vars.types.animations);return"Oh no! The animation "+JSON.stringify(n.type)+" doesn't seem to exist. It can only be one of these:\n"+e.reduce((t,i,n)=>t+"  â€¢ "+JSON.stringify(i)+" -> "+r.vars.types.animations[i].description+(n==e.length-1?"":"\n"),"")}let s={...r.vars.checks.animation,...a.args},l=["x","y","color","initialSize","size"];e.internal={setDefaults:[]};for(let t in l){let i=l[t];s[i]&&(n.hasOwnProperty(i)||(s[i].required?s[i].required=!1:e.internal.setDefaults.push(i)))}t({ob:e.onClick.animation,where:i,syntax:s})}},spriteDatas:(e,t,i,n,r,a)=>{let s=Bagel.internal.render.texture.get(".BagelGUI.button.circle",t),l=Math.floor(e.size*t.internal.renderer.scaleX*1.05);if(!s||s.width<l){let e=document.createElement("canvas");e.width=l,e.height=l;let i=e.getContext("2d");i.beginPath(),i.arc(e.width/2,e.height/2,e.width/2,0,2*Math.PI),i.fill(),Bagel.internal.render.texture.new(".BagelGUI.button.circle",e,t,!0,"static")}const o=[];if(o.push({scripts:{steps:{mouseUp:(e,t)=>{let i=e.vars.element;if(!t.input.mouse.down&&e.vars.clicked&&(!e.vars.clickLock||e.width==i.size)&&(t.playSound(".BagelGUI.clickUp"),e.vars.clicked=!1,e.vars.clickResetting=!0,e.vars.clickLock=!1,e.vars.vel+=.05,"object"==typeof i.onClick)){let t=i.onClick;e.vars.menuSprite.animateSubmenuChange(t.submenu,t.animation,{x:i.x,y:i.y,initialSize:i.size,size:i.size,color:i.color},e.vars.element.internal.setDefaults)}},mouseDown:(e,t)=>{e.vars.vel-=.1,e.vars.clicked||(t.playSound(".BagelGUI.click"),e.vars.clicked=!0,e.width<e.vars.maxSize?e.vars.vel+=3:e.vars.vel-=.3,e.vars.clickResetting=!1,"function"==typeof e.vars.element.onClick?e.vars.element.onClick(e.vars.element,e,e.vars.menuSprite):e.vars.clickLock=!0),"string"==typeof e.vars.element.onHover&&(e.vars.elementTypeVars.hoverText=e.vars.element.onHover)},mouseTouch:(e,t)=>{e.vars.vel+=.1,e.vars.touched||(t.playSound(".BagelGUI.touch"),"function"==typeof e.vars.element.onHover&&e.vars.element.onHover(e.vars.element,e,e.vars.menuSprite),e.vars.touched=!0),"string"==typeof e.vars.element.onHover&&(e.vars.elementTypeVars.hoverText=e.vars.element.onHover)}},init:[e=>{e.clone()}],main:[(e,t,i)=>{let n=e.width;e.vars.active&&(i("mouseUp"),e.touching.mouseCircles()||e.vars.clickLock?t.input.mouse.down&&!t.input.touch.dragging||e.vars.clickLock?i("mouseDown"):i("mouseTouch"):(e.vars.touched=!1,e.vars.vel-=.09,e.width==e.vars.element.size&&(e.vars.clickResetting=!1))),n+=e.vars.vel,e.vars.vel*=.9,n>e.vars.maxSize&&(n=e.vars.maxSize,e.vars.vel=0),e.vars.touched||n<e.vars.element.size&&(n=e.vars.element.size,e.vars.vel=0),n<e.vars.minSize&&(n=e.vars.minSize,e.vars.vel=0),e.width=n,e.height=n}]},width:e.size,height:e.size,vars:{maxSize:1.05*e.size,minSize:e.size,vel:0,touched:!1,clicked:!1,clickResetting:!1,clickLock:!1},img:".BagelGUI.button.circle",tint:e.color,clones:{tint:"#000000",scripts:{main:[e=>{e.x=e.parent.x,e.y=e.parent.y;let t=(e.parent.width-e.vars.element.size)/(e.vars.maxSize-e.vars.element.size);e.width=t*e.vars.maxSize,e.height=e.width,e.alpha=.05*t,0==e.width||e.parent.vars.clickResetting?e.visible=!1:(e.visible=!0,e.layer.bringToFront())}]}}}),e.icon&&o.push({img:e.icon,vars:{parent:i(0)},scripts:{init:[e=>{e.vars.parent=e.game.get.sprite(e.vars.parent),e.vars.ratio=e.height/e.width}],main:[e=>{e.x=e.vars.parent.x,e.y=e.vars.parent.y;let t=e.vars.ratio;t>1?(e.height=e.vars.parent.width*e.vars.element.iconSize,e.width=e.height/t):(e.width=e.vars.parent.width*e.vars.element.iconSize,e.height=e.width*t),e.visible=e.vars.parent.visible}]},minProcess:!0,deleteOnOtherDelete:!0}),e.onHover&&!a.hoverTextSprite){a.hoverTextSprite=!0;let e={...n.submenus[n.submenu].hoverText,text:"",type:"text",visible:!0},t={...e};e.vars={buttonTypeVars:a,fadeTime:e.fadeTime,fadeSpeed:1/(60*e.fadeTime)},delete e.fixedToCamera,delete e.fadeTime,e.scripts={main:[e=>{let t=e.vars.buttonTypeVars,i=t.hoverText;i&&(e.text=i),""==i?e.alpha-=e.vars.fadeSpeed:e.alpha+=e.vars.fadeSpeed,t.hoverText=""}]},r.vars.queueMakeSpriteElement((e,t,i,n)=>{n.hoverTextSprite=e},e,n,r,t,null,a)}return o},description:"A simple button that can trigger a submenu change or code to run."},text:{args:Bagel.internal.plugin.plugin.types.sprites.text.args,spriteDatas:(e,t)=>{let i=Bagel.internal.plugin.plugin.types.sprites.text.args,n={};for(let t in i)e.hasOwnProperty(t)&&(n[t]=e[t]);return{type:"text",...n}},description:"Some simple text. Has an almost idential syntax to the sprite type."},image:{args:{...Bagel.internal.plugin.plugin.types.sprites.sprite.args,color:{required:!1,types:["string"],description:'The colour to use instead of an image, any HTML colour. e.g "rgb(100, 50, 20)" or "#FF00FF".'}},preload:(e,t)=>{e.color||t.get.asset.img(e.img)},onMenuSpriteDelete:(e,t,i)=>{if(i){let e=".BagelGUI.color";Bagel.internal.render.texture.get(e,t)&&Bagel.internal.render.texture.delete(e,t)}},spriteDatas:(e,t)=>{let n=Bagel.internal.plugin.plugin.types.sprites.sprite.args,r={};for(let t in n)e.hasOwnProperty(t)&&(r[t]=e[t]);for(i in r.crop)null==r.crop[i]&&delete r.crop[i];if(e.color){let i=".BagelGUI.color";if(!Bagel.internal.render.texture.get(i,t)){let e=document.createElement("canvas");e.width=1,e.height=1,e.getContext("2d").fillRect(0,0,1,1),Bagel.internal.render.texture.new(i,e,t,!1,"static")}r.img=i,r.tint=e.color}return{type:"sprite",...r}},description:'Almost idential in syntax to the "sprite" sprite type, but you can set the "color" argument to an HTML colour instead of using an image if you want.'}}},checks:{ignoreElement:{type:"ignore",visible:"ignore",fixedToCamera:"ignore",x:"ignore",y:"ignore",left:"ignore",top:"ignore",right:"ignore",bottom:"ignore",internal:"ignore",vars:{required:!1,default:{},types:["object"],description:"An object where you can store data for this element."}},animation:{type:{required:!1,default:"scroll",types:["string"],description:"The name of the animation to use."}}}}}
